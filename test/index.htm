<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>rc_openpgpjs test suite</title>
	</head>
	<body>
		<div id="info">
			<h1>rc_openpgpjs test suite</h1>
			Click <a href="#" onclick="runAll();">here</a> to run all tests.
		</div>
		<div id="container" style="float:left;">
			<div id="keygen">
				<h2>Keygen</h2>
				<select id="gen_bits">
					<option value="1024">1024</option>
					<option value="2048">2048</option>
					<option value="4096">4096</option>
				</select>
				<input type="submit" onclick="testGenerateKeys();" value="Generate keypair" />
				<div>
					<textarea id="privkey"></textarea>
					<textarea id="pubkey"></textarea>
				</div>
			</div>


			<div id="encrypt">
				<h2>Encrypt</h2>
				<input type="text" id="string_to_encrypt" value="String to encrypt..." />
				<input type="button" value="Encrypt" onclick="testEncrypt();" />
				<div>
					<textarea id="encrypted"></textarea>
				</div>
			</div>
		</div>
		<div id="debug" style="float:right;min-width:50%;padding:5px;"></div>
		<script type="text/javascript" src="../../../program/js/jquery.min.js"></script>
		<script type="text/javascript" src="../js/openpgp.min.js"></script>
		<script type="text/javascript">
			openpgp.init();
			openpgp.config.debug = true;

			resetDebug();

			/**
			 * Returns array:
			 *   ["privateKey"] = privkey (armored)
			 *   ["publicKey"] = pubkey (armored)
			 */
			function generateKeys(bits, algo, ident, passphrase) {
				try {
					keys = openpgp.generate_key_pair(1, bits, ident, passphrase);
					arr = new Array();
					arr["privateKey"] = keys.privateKeyArmored;
					arr["publicKey"] = keys.publicKeyArmored;
					return(arr);
				} catch(e) {
					return false;
				}
			}

			/**
			 * Params:
			 *   pubkeys : Array containing public keys
			 *   text    : String to encrypt
			 *   sign    : Optional bool, if sign and encrypt set to 1
			 *   privkey : Required if sign is set
			 * Return:
			 *   Encrypted message (str)
			 */
			function encrypt(pubkeys, text, sign, privkey) {
				sign = (typeof sign === "undefined") ? 0 : 1;
				privkey = (typeof privkey === "undefined") ? 0 : privkey;
				try {
					encrypted = openpgp.write_encrypted_message(pubkeys, text);
					return(encrypted);
				} catch(e) {
					return false;
				}
			}

			function testDecrypt() {
				return decrypt($("#encrypted").html(), $("#privkey").html(), $("#gen_passphrase").val());
			}

			function testGenerateKeys() {
				try {
					bits = $("#gen_bits option:selected").text();
					keys = generateKeys(bits, 1, "test <test@foo.bar>", $("#gen_passphrase").val());
					$("#privkey").html(keys["privateKey"]);
					$("#pubkey").html(keys["publicKey"]);
					return true;
				} catch(e) {
					return false;
				}
			}

			function testEncrypt() {
				var pubkeys = new Array();
				var pub_key = openpgp.read_publicKey($("#pubkey").html());
				pubkeys.push(pub_key[0]);

				try {
					encrypted = encrypt(pubkeys, $("#string_to_encrypt").val());
					$("#encrypted").html(encrypted);
					return true;
				} catch(e) {
					return false;
				}
			}

			function decrypt(data, privkey_armored, passphrase) {
				var msg = openpgp.read_message(data);
    
				if(!msg) {
					return false;
				}

				if(!("decrypt" in msg[0])) {
					return false;
				}

				var priv_key = openpgp.read_privateKey(privkey_armored);
				var keymat = null;
				var sesskey = null;

				if(!priv_key[0].decryptSecretMPIs(passphrase)) {
					alert("wrong pass");
					return false;
				}

				// msg is encrypted
				for (var i = 0; i< msg[0].sessionKeys.length; i++) {
					if (priv_key[0].privateKeyPacket.publicKey.getKeyId() === msg[0].sessionKeys[i].keyId.bytes) {
						keymat = { key: priv_key[0], keymaterial: priv_key[0].privateKeyPacket};
						sesskey = msg[0].sessionKeys[i];
						break;
					}

					for (var j = 0; j < priv_key[0].subKeys.length; j++) {
						if (priv_key[0].subKeys[j].publicKey.getKeyId() === msg[0].sessionKeys[i].keyId.bytes) {
							keymat = { key: priv_key[0], keymaterial: priv_key[0].subKeys[j]};
							sesskey = msg[0].sessionKeys[i];
							break;
						}
					}
				}

				try {
					decrypted = msg[0].decrypt(keymat, sesskey);
					return decrypted;
				} catch (e) {
					return false;
				}
			}

			function runAll() {
				resetDebug();
				var fail = new Array();
				var success = new Array();
				var tests = new Array("testGenerateKeys", "testEncrypt", "testDecrypt");
				for(var i = 0; i < tests.length; i++)
				{
					if(window[tests[i]]()) {
						success.push(tests[i]);
					} else {
						fail.push(tests[i]);
					}
				}
				alert("All tests completed, success: " + success.length + ", fail: " + fail.length);
				if(fail.length > 0) {
					var fails = "";
					for(var i = 0; i < fail.length; i++) {
						var fails = fails + fail[i] + ", ";
					}
					alert("The following tests failed: " + fails);
				}
			}

			function showMessages(msg) { $("#debug").append(msg); }

			function resetDebug() {
				$("#debug").html("<strong>Debug</strong> <input type='button' onclick='resetDebug();' value='reset' />");
			}
		</script>
	</body>
</html>
